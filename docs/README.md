# Notation

The following notation is used throughout the diagrams:

## Keys

* $P_i$: **P**rivate key of user $i$
* $U_i$: P**u**blic key of user $i$
* $S_i$: **S**ymmetric key
* $S_{ab}$: **S**hared key of users $a$ and $b$
* $W_i$: Pass**w**ord-based key of user $i$

## Identifiers

* $s$: **S**erver
* $c$: **C**lient, sender
* $r$: Client, **r**ecipient
* $m$: **M**essage
* $I_s$: ID of user/message $s$

## Functions

* $H(v)$: Compute hash of value $v$
* $E_S(m)$: Encrypt message $m$ using symmetric key $S$
* $D_S(m)$: Decrypt message $m$ using symmetric key $S$
* $HKDF(h)$: Derive key from hash $h$
* $DH(P_c, U_r)$: Establish shared key (Diffie-Hellman) using private key $P_c$ and public key $U_r$. Note that $DH(U_a, P_b) = DH(P_a, U_b)$

## Misc

* $\tau$: MAC tag
* $t$: Timestamp

# Protocol

## Identifying
Identification is the process of creating a user account. In that scenario, the user first initializes a cryptographic keypair locally, and then sends that keypair to the server along with its user ID, while encrypting the private key with their password.

!["Identifying"](identify.png)

## Retrieving keys
The process of key retrieval is performed when a user switches devices and has to retreive their credentials. In that process, the user also establishes the shared key with the server. If the keys are already present on the device, then this step is not necessary.

!["Retrieving keys"](retrieve_keys.png)

## Resetting password
Password reset is used when a user whishes to change their password. In order to do so, the user encrypts its private key using the new password. The steps are the same as with the initial password. The data is then sent to the server.

!["Resetting the password"](reset_password.png)

## Sending messages
Messages are encrypted multiple times. First, the message is encrypted using the shared sender-recipient symmetric key $S_{cr}$. Then, this encrypted data is bundled with the metadata (ID of sender, ID of recipient, timestamp), and is encrypted using the shared sender-server symmetric key $S_{cs}$. Once the server receives the data, it decrypts it using $S_{cs}$, and encrypts it using a newly generated secret key $S_m$. This key is used for this specific message only. 

!["Sending a message"](send.png)

## Listing messages
In order to download and unlock messages, the user has to be able to list messages sent to them.

!["Listing all messages"](list_messages.png)

## Downloading messages
Messages are downloaded while still being encrypted by the one-time key generated by the server. In order to download a message, a user has to "authenticate" first by sending their ID as authenticated data in message using the recipient-server shared key $S_{sr}$, which is established when retrieving the keys.

!["Downloading a message"](download.png)

## Unlocking messages
When the user whishes to unlock a message they make a request to the server for the specific message. If the authentication is valid, and if the timestamp is in the past, the one-time symmetric key is sent to the user for them to unlock the message.

!["Unlocking a message"](unlock.png)

# Cryptographic parameters

**WIP**

* Hash function: Argon2id with output of 256 bits
* Symmetric encryption: XChaCha20 (libsodium)
* Authentication: Poly1305 (libsodium)
* Asymmetric keys: 256 bits X25519 (libsodium)
* Symmetric keys: 128 bits when generated randomly, 256 bits for shared keys built using Diffie-Hellman?
* Diffie-Hellman: ECDH X25519 (libsodium)
* HKFD: ?
* Nonce: 192 bits nonce (XChaCha20 libsodium)

This would result in an overall security of 128 bits. Because even if the shared keys are symmetric and 256 bits long, you only have to bruteforce one of the private keys associated with it to compute it, which is a 2^128 operation algorithm for X25519 if I understand correctly